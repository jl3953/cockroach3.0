// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: smdbrpc/protos/demotehotkeys.proto

package execinfrapb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type KVVersion struct {
	Key       *string       `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value     []byte        `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	Timestamp *HLCTimestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Hotness   *int64        `protobuf:"varint,4,opt,name=hotness" json:"hotness,omitempty"`
}

func (m *KVVersion) Reset()         { *m = KVVersion{} }
func (m *KVVersion) String() string { return proto.CompactTextString(m) }
func (*KVVersion) ProtoMessage()    {}
func (*KVVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_demotehotkeys_92cd6f766b0d4bc6, []int{0}
}
func (m *KVVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KVVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVVersion.Merge(dst, src)
}
func (m *KVVersion) XXX_Size() int {
	return m.Size()
}
func (m *KVVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_KVVersion.DiscardUnknown(m)
}

var xxx_messageInfo_KVVersion proto.InternalMessageInfo

type KVDemotionStatus struct {
	Key                   *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	IsSuccessfullyDemoted *bool   `protobuf:"varint,2,opt,name=is_successfully_demoted,json=isSuccessfullyDemoted" json:"is_successfully_demoted,omitempty"`
}

func (m *KVDemotionStatus) Reset()         { *m = KVDemotionStatus{} }
func (m *KVDemotionStatus) String() string { return proto.CompactTextString(m) }
func (*KVDemotionStatus) ProtoMessage()    {}
func (*KVDemotionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_demotehotkeys_92cd6f766b0d4bc6, []int{1}
}
func (m *KVDemotionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVDemotionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *KVDemotionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVDemotionStatus.Merge(dst, src)
}
func (m *KVDemotionStatus) XXX_Size() int {
	return m.Size()
}
func (m *KVDemotionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_KVDemotionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_KVDemotionStatus proto.InternalMessageInfo

type NumKeysToDemote struct {
	QpsInExcess     *int64 `protobuf:"varint,1,opt,name=qps_in_excess,json=qpsInExcess" json:"qps_in_excess,omitempty"`
	NumKeysToDemote *int64 `protobuf:"varint,2,opt,name=num_keys_to_demote,json=numKeysToDemote" json:"num_keys_to_demote,omitempty"`
}

func (m *NumKeysToDemote) Reset()         { *m = NumKeysToDemote{} }
func (m *NumKeysToDemote) String() string { return proto.CompactTextString(m) }
func (*NumKeysToDemote) ProtoMessage()    {}
func (*NumKeysToDemote) Descriptor() ([]byte, []int) {
	return fileDescriptor_demotehotkeys_92cd6f766b0d4bc6, []int{2}
}
func (m *NumKeysToDemote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumKeysToDemote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	b = b[:cap(b)]
	n, err := m.MarshalTo(b)
	if err != nil {
		return nil, err
	}
	return b[:n], nil
}
func (dst *NumKeysToDemote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumKeysToDemote.Merge(dst, src)
}
func (m *NumKeysToDemote) XXX_Size() int {
	return m.Size()
}
func (m *NumKeysToDemote) XXX_DiscardUnknown() {
	xxx_messageInfo_NumKeysToDemote.DiscardUnknown(m)
}

var xxx_messageInfo_NumKeysToDemote proto.InternalMessageInfo

func init() {
	proto.RegisterType((*KVVersion)(nil), "smdbrpc.KVVersion")
	proto.RegisterType((*KVDemotionStatus)(nil), "smdbrpc.KVDemotionStatus")
	proto.RegisterType((*NumKeysToDemote)(nil), "smdbrpc.NumKeysToDemote")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DemoteHotkeysGatewayClient is the client API for DemoteHotkeysGateway service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DemoteHotkeysGatewayClient interface {
	DemoteHotkeys(ctx context.Context, opts ...grpc.CallOption) (DemoteHotkeysGateway_DemoteHotkeysClient, error)
	DemoteByNums(ctx context.Context, in *NumKeysToDemote, opts ...grpc.CallOption) (*KVDemotionStatus, error)
}

type demoteHotkeysGatewayClient struct {
	cc *grpc.ClientConn
}

func NewDemoteHotkeysGatewayClient(cc *grpc.ClientConn) DemoteHotkeysGatewayClient {
	return &demoteHotkeysGatewayClient{cc}
}

func (c *demoteHotkeysGatewayClient) DemoteHotkeys(ctx context.Context, opts ...grpc.CallOption) (DemoteHotkeysGateway_DemoteHotkeysClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DemoteHotkeysGateway_serviceDesc.Streams[0], "/smdbrpc.DemoteHotkeysGateway/DemoteHotkeys", opts...)
	if err != nil {
		return nil, err
	}
	x := &demoteHotkeysGatewayDemoteHotkeysClient{stream}
	return x, nil
}

type DemoteHotkeysGateway_DemoteHotkeysClient interface {
	Send(*KVVersion) error
	Recv() (*KVDemotionStatus, error)
	grpc.ClientStream
}

type demoteHotkeysGatewayDemoteHotkeysClient struct {
	grpc.ClientStream
}

func (x *demoteHotkeysGatewayDemoteHotkeysClient) Send(m *KVVersion) error {
	return x.ClientStream.SendMsg(m)
}

func (x *demoteHotkeysGatewayDemoteHotkeysClient) Recv() (*KVDemotionStatus, error) {
	m := new(KVDemotionStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *demoteHotkeysGatewayClient) DemoteByNums(ctx context.Context, in *NumKeysToDemote, opts ...grpc.CallOption) (*KVDemotionStatus, error) {
	out := new(KVDemotionStatus)
	err := c.cc.Invoke(ctx, "/smdbrpc.DemoteHotkeysGateway/DemoteByNums", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DemoteHotkeysGatewayServer is the server API for DemoteHotkeysGateway service.
type DemoteHotkeysGatewayServer interface {
	DemoteHotkeys(DemoteHotkeysGateway_DemoteHotkeysServer) error
	DemoteByNums(context.Context, *NumKeysToDemote) (*KVDemotionStatus, error)
}

func RegisterDemoteHotkeysGatewayServer(s *grpc.Server, srv DemoteHotkeysGatewayServer) {
	s.RegisterService(&_DemoteHotkeysGateway_serviceDesc, srv)
}

func _DemoteHotkeysGateway_DemoteHotkeys_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DemoteHotkeysGatewayServer).DemoteHotkeys(&demoteHotkeysGatewayDemoteHotkeysServer{stream})
}

type DemoteHotkeysGateway_DemoteHotkeysServer interface {
	Send(*KVDemotionStatus) error
	Recv() (*KVVersion, error)
	grpc.ServerStream
}

type demoteHotkeysGatewayDemoteHotkeysServer struct {
	grpc.ServerStream
}

func (x *demoteHotkeysGatewayDemoteHotkeysServer) Send(m *KVDemotionStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *demoteHotkeysGatewayDemoteHotkeysServer) Recv() (*KVVersion, error) {
	m := new(KVVersion)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DemoteHotkeysGateway_DemoteByNums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumKeysToDemote)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DemoteHotkeysGatewayServer).DemoteByNums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/smdbrpc.DemoteHotkeysGateway/DemoteByNums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DemoteHotkeysGatewayServer).DemoteByNums(ctx, req.(*NumKeysToDemote))
	}
	return interceptor(ctx, in, info, handler)
}

var _DemoteHotkeysGateway_serviceDesc = grpc.ServiceDesc{
	ServiceName: "smdbrpc.DemoteHotkeysGateway",
	HandlerType: (*DemoteHotkeysGatewayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DemoteByNums",
			Handler:    _DemoteHotkeysGateway_DemoteByNums_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DemoteHotkeys",
			Handler:       _DemoteHotkeysGateway_DemoteHotkeys_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "smdbrpc/protos/demotehotkeys.proto",
}

func (m *KVVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.Value != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(m.Timestamp.Size()))
		n1, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Hotness != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(*m.Hotness))
	}
	return i, nil
}

func (m *KVDemotionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVDemotionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(len(*m.Key)))
		i += copy(dAtA[i:], *m.Key)
	}
	if m.IsSuccessfullyDemoted != nil {
		dAtA[i] = 0x10
		i++
		if *m.IsSuccessfullyDemoted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NumKeysToDemote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumKeysToDemote) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QpsInExcess != nil {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(*m.QpsInExcess))
	}
	if m.NumKeysToDemote != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDemotehotkeys(dAtA, i, uint64(*m.NumKeysToDemote))
	}
	return i, nil
}

func encodeVarintDemotehotkeys(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *KVVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDemotehotkeys(uint64(l))
	}
	if m.Value != nil {
		l = len(m.Value)
		n += 1 + l + sovDemotehotkeys(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovDemotehotkeys(uint64(l))
	}
	if m.Hotness != nil {
		n += 1 + sovDemotehotkeys(uint64(*m.Hotness))
	}
	return n
}

func (m *KVDemotionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = len(*m.Key)
		n += 1 + l + sovDemotehotkeys(uint64(l))
	}
	if m.IsSuccessfullyDemoted != nil {
		n += 2
	}
	return n
}

func (m *NumKeysToDemote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QpsInExcess != nil {
		n += 1 + sovDemotehotkeys(uint64(*m.QpsInExcess))
	}
	if m.NumKeysToDemote != nil {
		n += 1 + sovDemotehotkeys(uint64(*m.NumKeysToDemote))
	}
	return n
}

func sovDemotehotkeys(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDemotehotkeys(x uint64) (n int) {
	return sovDemotehotkeys(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *KVVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDemotehotkeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &HLCTimestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hotness", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hotness = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDemotehotkeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVDemotionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDemotehotkeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVDemotionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVDemotionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Key = &s
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSuccessfullyDemoted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsSuccessfullyDemoted = &b
		default:
			iNdEx = preIndex
			skippy, err := skipDemotehotkeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumKeysToDemote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDemotehotkeys
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumKeysToDemote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumKeysToDemote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QpsInExcess", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QpsInExcess = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumKeysToDemote", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumKeysToDemote = &v
		default:
			iNdEx = preIndex
			skippy, err := skipDemotehotkeys(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDemotehotkeys
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDemotehotkeys(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDemotehotkeys
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDemotehotkeys
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDemotehotkeys
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDemotehotkeys
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDemotehotkeys(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDemotehotkeys = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDemotehotkeys   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("smdbrpc/protos/demotehotkeys.proto", fileDescriptor_demotehotkeys_92cd6f766b0d4bc6)
}

var fileDescriptor_demotehotkeys_92cd6f766b0d4bc6 = []byte{
	// 392 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x51, 0xc1, 0xae, 0xd2, 0x40,
	0x14, 0xed, 0x58, 0xcd, 0x93, 0xe1, 0xbd, 0x40, 0x26, 0x10, 0x2b, 0x31, 0x93, 0xa6, 0xab, 0x26,
	0x46, 0x30, 0x98, 0xf8, 0x01, 0x08, 0x11, 0x83, 0x61, 0x51, 0x08, 0x0b, 0x63, 0xd2, 0x94, 0x32,
	0x84, 0x06, 0x3a, 0x53, 0x7a, 0xa7, 0x4a, 0xb7, 0x7e, 0x81, 0xff, 0xe0, 0xcf, 0xb0, 0x64, 0xc9,
	0x52, 0xcb, 0x8f, 0x98, 0x76, 0x00, 0x81, 0x98, 0xb7, 0xbb, 0xf7, 0xdc, 0x33, 0xe7, 0xde, 0x73,
	0x06, 0x5b, 0x10, 0xce, 0xa6, 0x71, 0xe4, 0xb7, 0xa2, 0x58, 0x48, 0x01, 0xad, 0x19, 0x0b, 0x85,
	0x64, 0x0b, 0x21, 0x97, 0x2c, 0x85, 0x66, 0x01, 0x92, 0xbb, 0x23, 0xa7, 0xf1, 0xea, 0x86, 0x7c,
	0x6c, 0x15, 0xcd, 0xfa, 0x81, 0x70, 0x69, 0x30, 0x99, 0xb0, 0x18, 0x02, 0xc1, 0x49, 0x15, 0xeb,
	0x4b, 0x96, 0x1a, 0xc8, 0x44, 0x76, 0xc9, 0xc9, 0x4b, 0x52, 0xc3, 0xcf, 0xbe, 0x79, 0xab, 0x84,
	0x19, 0x4f, 0x4c, 0x64, 0xdf, 0x3b, 0xaa, 0x21, 0xef, 0x70, 0x49, 0x06, 0x21, 0x03, 0xe9, 0x85,
	0x91, 0xa1, 0x9b, 0xc8, 0x2e, 0xb7, 0xeb, 0xcd, 0x93, 0x70, 0xff, 0xf3, 0x87, 0xf1, 0x69, 0xe8,
	0xfc, 0xe3, 0x11, 0x03, 0xdf, 0x2d, 0x84, 0xe4, 0x0c, 0xc0, 0x78, 0x6a, 0x22, 0x5b, 0x77, 0x4e,
	0xad, 0xf5, 0x15, 0x57, 0x07, 0x93, 0x6e, 0x6e, 0x22, 0x10, 0x7c, 0x24, 0x3d, 0x99, 0xc0, 0x7f,
	0x4e, 0x79, 0x8f, 0x5f, 0x04, 0xe0, 0x42, 0xe2, 0xfb, 0x0c, 0x60, 0x9e, 0xac, 0x56, 0xa9, 0xab,
	0x8c, 0xcf, 0x8a, 0xe3, 0x9e, 0x3b, 0xf5, 0x00, 0x46, 0x17, 0xd3, 0xae, 0x1a, 0x5a, 0x53, 0x5c,
	0x19, 0x26, 0xe1, 0x80, 0xa5, 0x30, 0x16, 0x0a, 0x23, 0x16, 0x7e, 0x58, 0x47, 0xe0, 0x06, 0xdc,
	0x65, 0x9b, 0x9c, 0x5f, 0xac, 0xd1, 0x9d, 0xf2, 0x3a, 0x82, 0x4f, 0xbc, 0x57, 0x40, 0xe4, 0x35,
	0x26, 0x3c, 0x09, 0xdd, 0x3c, 0x52, 0x57, 0x8a, 0xe3, 0xaa, 0x62, 0x93, 0xee, 0x54, 0xf8, 0xb5,
	0x60, 0xfb, 0x17, 0xc2, 0x35, 0x55, 0xf6, 0xd5, 0x2f, 0x7c, 0xf4, 0x24, 0xfb, 0xee, 0xa5, 0xa4,
	0x8b, 0x1f, 0xae, 0x70, 0x42, 0xce, 0x39, 0x9d, 0x63, 0x6f, 0xbc, 0xbc, 0xc0, 0xae, 0x63, 0xb0,
	0x34, 0x1b, 0xbd, 0x45, 0xa4, 0x87, 0xef, 0x95, 0x4a, 0x27, 0x1d, 0x26, 0x21, 0x10, 0xe3, 0xfc,
	0xe0, 0xc6, 0xd9, 0xa3, 0x52, 0x9d, 0x37, 0xdb, 0x3f, 0x54, 0xdb, 0x66, 0x14, 0xed, 0x32, 0x8a,
	0xf6, 0x19, 0x45, 0xbf, 0x33, 0x8a, 0x7e, 0x1e, 0xa8, 0xb6, 0x3b, 0x50, 0x6d, 0x7f, 0xa0, 0xda,
	0x97, 0x32, 0xdb, 0x30, 0x3f, 0xe0, 0xf3, 0xd8, 0x8b, 0xa6, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x5e, 0x35, 0xf4, 0x6b, 0x67, 0x02, 0x00, 0x00,
}
